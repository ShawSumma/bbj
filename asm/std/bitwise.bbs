
.include "boot.bbs"

.macro logic bits, op, out, lhs, rhs
    jmp over
table:
    .raw op
over:
    .loop n, bits
        mov mov_lhs+32, lhs+n
        mov mov_lhs+32+1, rhs+n
    mov_lhs:
        mov out+n, table
    .end
.end

.macro word_logic op, out, lhs, rhs
    logic 32, op, out, lhs, rhs
.end

.macro bit_logic op, out, lhs, rhs
    logic 1, op, out, lhs, rhs
.end

.macro xor out, lhs, rhs
    word_logic 6, out, lhs, rhs
.end

.macro and out, lhs, rhs
    word_logic 8, out, lhs, rhs
.end

.macro or out, lhs, rhs
    word_logic 14, out, lhs, rhs
.end

.macro not out, lhs
    word_logic 1, out, lhs, lhs
.end

.macro bxor out, lhs, rhs
    bit_logic 6, out, lhs, rhs
.end

.macro band out, lhs, rhs
    bit_logic 8, out, lhs, rhs
.end

.macro bor out, lhs, rhs
    bit_logic 14, out, lhs, rhs
.end

.macro bnot out, lhs
    bit_logic 1, out, lhs, lhs
.end

.macro shl n, out, input
    jmp next
zero:
    .raw 0
next:
    .local max 32-n
    .loop i, max
        mov out+max-i, input+max-1-i
    .end
    .loop i, n
        mov out+i, zero
    .end
.end

.macro shl out, input
    shl 1, out, input
.end

.macro shr out, input
    jmp next
zero:
    .raw 0
next:
    mov out, zero
    .loop i, 31
        mov out+i, input+i+1
    .end
.end

.macro if_eq lhs, rhs, is_eq
    jmp next
tmp:
    .raw 0
next:
    if_zero lhs, lhs_zero
    xor tmp, lhs, rhs
    if_zero tmp, is_eq
    jmp end
lhs_zero:
    if_zero rhs, is_eq
end:
.end
